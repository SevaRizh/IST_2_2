-- Переключаемся на нашу базу данных
-- Заметьте что тут без квадратных скобок. Мне так больше нравится.
USE orders;
-- ===========================================================================

-- Щас мы будем создавать наши таблицы

-- Создаём таблицу с продавцами
CREATE TABLE salespeople (
    -- В таблице задаём столбец с именем "snum и типом int (целое число), которое не может быть пустым
    snum int NOT NULL,
    -- Второй столбец с именем "sname" и типом nchar(20), то есть символьный тип данных фиксированной длины, в нашем случае - 20 символов.
    -- nchar - сокращение от national character, один символ занимает 2 байта
    -- Тоже не может быть пустым
    sname nchar(20) NOT NULL,
    -- Следующий столбец с именем "city", он уже может быть пустым.
    -- Тут важно отметить, что пустая строка и NULL - разные вещи. Когда я говорю "пустая ячейка", значит там NULL. Когда я говорю, "пустая строка", это значит "".
    city nchar(20) NULL,
    -- Последний столбец имеет тип decimal(3,3), то есть дробное десятичное число с фиксированной точностью и масштабом.
    -- Для удобства поменяем на decimal(p,s).
    -- p - это точность, максимальное общее число хранимых десятичных разрядов. Это число включает символы слева и справа от десятичной запятой. Не может быть меньше 1.
    -- s - это масштаб, максимальное число хранимых десятичных разрядов справа от десятичной запятой. Не может быть больше p и меньше 0.
    -- s отнимается от p для определения максимального количества цифр слева от десятичной запятой.
    -- То есть в нашем случае, слева от десятичной запятой не должно быть никаких цифр! Это важно!
    comm decimal(3,3) NULL,

    -- Далее мы задаём ограничение
    -- "PK_salespeople" - это название ограничения.
    -- "PRIMARY KEY" - это что за ограничение мы создаём
    -- "snum" - столбец, к которому применяется ограничение
    -- В данном случае мы требуем, чтобы snum - было главным значением в таблице, так называемым "первичным ключом".
    -- У таблицы может быть только один первичный ключ, а значения этого столбца не могут быть NULL и должны быть уникальны.
    -- При этом, если вместо "snum" написать названия нескольких столбцов, то комбинация этих столбцов будет первичным ключом!
    CONSTRAINT PK_salespeople PRIMARY KEY (snum)
);

-- Создаём таблицу с покупателями
-- В основном оно аналогично верхней таблице
CREATE TABLE customers (
    cnum int        NOT NULL,
    snum int        NULL,
    cname nchar(20) NOT NULL,
    city nchar(20)  NULL,
    rating int      NULL,

    -- Кроме тут. Отсутствует слово "CONSTRAINT". Но, на самом деле - насрать.
    -- Суть та же самая, мы указываем такое же ограничение, но безымянное.
    PRIMARY KEY (cnum)
);

-- Создаём последнюю таблицу с заказами
-- Опять всё примерно так же
CREATE TABLE orders (
    onum int            NOT NULL,
    cnum int            NULL,
    snum int            NULL,
    amt decimal(7, 3)   NOT NULL,
    -- Новое тут. smalldatetime это тип данных для хранения даты и времени.
    -- Время представлено в 24-часовом формате с секундами, всегда равными нулю (:00), без долей секунд.
    odate smalldatetime NULL,

    CONSTRAINT PK_orders PRIMARY KEY (onum)
);
-- ===========================================================================

-- А здесь мы будем МЕНЯТЬ ранее созданные таблицы.
-- Причём менять не содержимое, а "определение" таблиц, их параметры, так сказать.

-- Хотим менять таблицу "customers"
ALTER TABLE customers
-- Добавляем ограничение с именем "FK_customers_salespeople"
ADD CONSTRAINT FK_customers_salespeople
-- FOREIGN KEY REFERENCES - это ограничение, которое обеспечивает ссылочную целостность данных в этом столбце или столбцах.
-- То есть, мы говорим, что поле "snum"из текущей таблицы (orders) связано с полем "snum" таблицы salespeople.
-- Причём главным тут является именно таблица salespeople.
-- То есть, когда мы добавляем запись в таблицу customers и в "snum" записываем например "10", значит
-- в таблице salespeople обязательно должна уже существовать запись, где snum равно "10".
-- Иначе - магия не заработает.
FOREIGN KEY (snum) REFERENCES salespeople (snum);

-- Абсолютно идентично правим таблицу orders
ALTER TABLE orders
-- Однако обратите внимание на названия ограничений. Это необязательно так делать, но подход вполне производственный:
-- Имя ограничения состоит из:
-- 1. FK - аббревиатура для FOREIGN KEY. То есть указан тип ограничение.
--    Когда мы создавали выше CONSTRAINT PRIMARY KEY, то имя ограничения было с префиксом PK
-- 2. customers - название главной таблицы, куда мы ссылаемся
-- 3. orders - название второстепенной таблицы, которая ссылается
-- То есть в названии ограничения сразу отображена его логика, что оно ограничивает
-- Таким образом взглянув на название FK_customers_orders легко сказать, что это ссылочная свзять таблицы orders на таблицу customers.
ADD CONSTRAINT FK_customers_orders
FOREIGN KEY (cnum) REFERENCES customers (cnum);

-- Всё идентично, кроме названия
-- Тут вполне можно было написать просто "orders" и всё бы работало.
-- Но сюда было добавлено название схемы. Если вы в Azure Data Studio откроете "домашнюю" страничку нашей БД,
-- то увидите список наших созданных таблиц. И там есть колонка "Schema", и у каждой таблицы написано "dbo".
-- Что такое "схема" в двух словах не объяснить, читайте тут:
-- https://ru.stackoverflow.com/questions/1190293/Что-такое-schema-в-БД
-- На самом деле можно было указать имя таблицы ещё вот так: "orders.dbo.orders", где первый orders - название БД.
-- То есть полный формат записи - database_name.schema_name.table_name
ALTER TABLE dbo.orders
ADD CONSTRAINT FK_salespeople_orders
FOREIGN KEY (snum) REFERENCES salespeople (snum);
